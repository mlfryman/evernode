CREATE OR REPLACE FUNCTION query_notes (uid integer, lmt integer, ofst integer)
RETURNS TABLE ("noteId" integer, title varchar, "updatedAt" timestamp, "tagIds" integer[], "tagNames" varchar[]) AS $$

DECLARE

BEGIN
  RETURN QUERY
    -- select the note title, aggregated tags grouped on "noteId", & timestamp "updatedAt" from the notes table
    SELECT n.id AS "noteId", n.title, n.updated_at AS "updatedAt", array_agg(t.id) AS "tagIds", array_agg(t.name) AS "tagNames"
    FROM notes n
    -- (1) An inner join is performed on notes n & notes_tags nt.
    -- For each row in n that does not satisfy the join condition with any row in nt,
    -- a joined row is added with null values in columns of nt.
    -- Thus, the joined table always has at least one row for each row in n.
    LEFT OUTER JOIN notes_tags nt ON n.id = nt.note_id
    -- (2) An inner join is performed on tags t & notes_tags nt.
    -- For each row in t that does not satisfy the join condition with any row in nt,
    -- a joined row is added with null values in columns of nt.
    -- Thus, the joined table always has at least one row for each row in t.
    LEFT OUTER JOIN tags t ON nt.tag_id = t.id
    -- select only the notes that belong to the logged in user
    WHERE n.user_id = uid
    -- group the notes by "noteId", so that each note only has 1 row.  Tags are displayed in aggregate form.
    GROUP BY n.id
    -- list the notes in descending order by "updatedAt"
    ORDER BY n.updated_at DESC
    -- LIMIT and OFFSET allow you to retrieve just a portion of the rows that are generated by the rest of the query
    -- OFFSET says to skip that many rows before beginning to return rows.
    OFFSET ofst
    -- If a limit # is given, no more than that # rows will be returned
    LIMIT lmt;

END;
$$ LANGUAGE plpgsql;
